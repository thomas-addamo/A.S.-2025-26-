<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simulatore Scheduling — (FCFS, SJF, RR, Priority)</title>
<style>
	/* UI minimal e leggibile */
	body{font-family:Inter,Arial,sans-serif;background:#f6f8fb;color:#102331;margin:20px}
	.container{max-width:1100px;margin:auto;display:grid;grid-template-columns:1fr 520px;gap:18px}
	.card{background:#fff;border-radius:10px;padding:14px;box-shadow:0 6px 18px rgba(16,35,49,0.06)}
	h1{font-size:1.15rem;margin:0 0 8px}
	label{display:block;font-size:0.9rem;color:#415a6b;margin-top:8px}
	textarea{width:100%;height:130px;font-family:monospace;padding:10px;border-radius:8px;border:1px solid #e3eef6;background:#fbfeff}
	.row{display:flex;gap:8px;align-items:center;margin-top:10px}
	select,input[type=number]{padding:8px;border-radius:8px;border:1px solid #dceff8;background:#fff}
	button{padding:8px 12px;border-radius:8px;border:none;background:#0b6fc3;color:#fff;cursor:pointer}
	button.secondary{background:#6fb3c9}
	.small{font-size:0.85rem;color:#5b7b8b}
	.table{width:100%;border-collapse:collapse;margin-top:12px}
	.table th,.table td{border:1px solid #e9f4fb;padding:8px;text-align:center;font-size:0.9rem}
	.gantt{display:block;margin-top:12px;padding:10px;border-radius:8px;background:#f7fbfe;border:1px solid #e6f3fb;overflow:auto}
	.gantt .block{display:inline-flex;align-items:center;justify-content:center;height:36px;margin:2px;border-radius:6px;color:#052233;font-weight:700;padding:6px}
	.legend{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}
	.legend .item{display:flex;align-items:center;gap:6px;font-size:0.9rem}
	.color{width:18px;height:18px;border-radius:4px}
	.footer-note{font-size:0.85rem;color:#577383;margin-top:10px}
	@media (max-width:980px){.container{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
	<div class="card">
		<h1>Simulazione Scheduling (input JSON scalabile)</h1>
		<div class="small">Incolla un array JSON di task oppure genera N task con la "IA" (simulazione). Ogni task: {"id","arrival","burst","priority"}.</div>

		<label>JSON input dei task:
			<textarea id="jsonInput">[
  {"id":"P1","arrival":0,"burst":5,"priority":2},
  {"id":"P2","arrival":1,"burst":3,"priority":1},
  {"id":"P3","arrival":2,"burst":8,"priority":3}
]</textarea>
		</label>

		<div class="row">
			<label class="small">Genera N task:
				<input id="genCount" type="number" value="6" min="1" style="width:80px">
			</label>
			<button id="btnGen">Genera (IA)</button>
			<button id="btnLoad" class="secondary">Carica esempio</button>
		</div>

		<label>Algoritmo:
			<select id="algo">
				<option value="compare">Confronta tutti</option>
				<option value="fcfs">FCFS</option>
				<option value="sjf">SJF (non-preemptive)</option>
				<option value="rr">Round Robin</option>
				<option value="priority">Priority</option>
			</select>
		</label>

		<label id="quantumLabel" style="display:none">Quantum (RR):
			<input id="quantum" type="number" value="2" min="1" style="width:80px">
		</label>

		<div class="row">
			<label class="small"><input type="checkbox" id="showSteps"> Mostra schedule (console)</label>
			<button id="btnRun">Esegui</button>
			<button id="btnClear" class="secondary">Pulisci</button>
		</div>

		<div class="footer-note">Suggerimento IA: il pulsante "Genera (IA)" crea un set plausibile di task; poi puoi confrontare gli algoritmi per vedere quale minimizza l'Average Waiting.</div>
	</div>

	<div class="card">
		<h1>Risultati</h1>
		<div id="summary" class="small">Nessuna simulazione eseguita.</div>
		<div id="results"></div>
	</div>
</div>

<script>
/* Utils e parsing */
function parseTasks(txt){
	try{
		const arr = JSON.parse(txt);
		if(!Array.isArray(arr)) throw new Error('L\'input deve essere un array di task');
		return arr.map((t,i)=>({
			id: String(t.id ?? ('T'+(i+1))),
			arrival: Number(t.arrival ?? 0),
			burst: Math.max(0, Math.floor(Number(t.burst ?? 0))),
			priority: Number(t.priority ?? 0)
		})).sort((a,b)=>a.arrival - b.arrival || a.id.localeCompare(b.id));
	}catch(e){
		alert('Errore JSON: '+e.message);
		return null;
	}
}

/* Generatore "IA" semplice: distribuzione casuale ma leggibile */
function generateTasks(n){
	const out=[];
	for(let i=0;i<n;i++){
		const id='P'+(i+1);
		const arrival=Math.floor(Math.random()*8); // 0..7
		const burst=1+Math.floor(Math.random()*10); // 1..10
		const priority=1+Math.floor(Math.random()*5);
		out.push({id,arrival,burst,priority});
	}
	out.sort((a,b)=>a.arrival - b.arrival || a.id.localeCompare(b.id));
	return out;
}

/* Metriche comuni */
function computeMetrics(schedule, tasks){
	const map={};
	tasks.forEach(t=>map[t.id]=Object.assign({},t));
	for(const seg of schedule){
		if(!map[seg.id]) continue;
		map[seg.id].completion = Math.max(map[seg.id].completion ?? 0, seg.end);
	}
	const rows=[];
	let totalW=0,totalT=0,totalCPU=0;
	for(const id of Object.keys(map).sort()){
		const t=map[id];
		t.completion = t.completion ?? t.arrival;
		t.turnaround = t.completion - t.arrival;
		t.waiting = t.turnaround - t.burst;
		totalW += t.waiting;
		totalT += t.turnaround;
		totalCPU += t.burst;
		rows.push(t);
	}
	const n = rows.length || 1;
	return {
		rows,
		avgWaiting: totalW/n,
		avgTurnaround: totalT/n,
		makespan: schedule.length ? Math.max(...schedule.map(s=>s.end)) : 0,
		totalCPU
	};
}

/* Rendering: tabella e gantt */
function renderTable(rows, container){
	const el=document.getElementById(container);
	if(!rows || rows.length===0){ el.innerHTML=''; return; }
	let html='<table class="table"><thead><tr><th>ID</th><th>Arrival</th><th>Burst</th><th>Priority</th><th>Completion</th><th>Turnaround</th><th>Waiting</th></tr></thead><tbody>';
	for(const r of rows){
		html+=`<tr><td>${r.id}</td><td>${r.arrival}</td><td>${r.burst}</td><td>${r.priority}</td><td>${r.completion}</td><td>${r.turnaround}</td><td>${r.waiting}</td></tr>`;
	}
	html+='</tbody></table>';
	el.innerHTML = html;
}

function renderGantt(schedule, container, tasks){
	const el=document.getElementById(container);
	el.innerHTML = '';
	if(!schedule.length){ el.innerHTML='<div class="small">Nessuna esecuzione</div>'; return; }
	const maxT = Math.max(...schedule.map(s=>s.end));
	const unit = Math.max(12, Math.floor(500 / Math.max(1, maxT)));
	const palette=['#4a90e2','#e94e77','#f5a623','#7ed321','#bd10e0','#50e3c2','#f8e71c','#8b572a'];
	const colors = {};
	tasks.forEach((t,i)=>colors[t.id]=palette[i%palette.length]);
	const gantt = document.createElement('div');
	gantt.className='gantt';
	// create a left spacer based on start times by adding empty gaps as needed
	// simple approach: append blocks in schedule order; width proportional to duration
	for(const seg of schedule){
		const b = document.createElement('div');
		b.className='block';
		b.style.background = colors[seg.id] || '#999';
		b.style.minWidth = Math.max(20, (seg.end - seg.start)*unit)+'px';
		b.title = `${seg.id} ${seg.start}→${seg.end}`;
		b.textContent = `${seg.id} (${seg.start}-${seg.end})`;
		gantt.appendChild(b);
	}
	// time ticks
	const ticks = document.createElement('div');
	ticks.style.display='flex';ticks.style.marginTop='8px';
	for(let t=0;t<=maxT;t++){
		const tk = document.createElement('div');
		tk.style.minWidth = unit+'px'; tk.style.textAlign='center'; tk.style.color='#5b7b8b'; tk.textContent = t;
		ticks.appendChild(tk);
	}
	el.appendChild(gantt);
	el.appendChild(ticks);

	// legend
	const legend = document.createElement('div');
	legend.className='legend';
	tasks.forEach(t=>{
		const it=document.createElement('div'); it.className='item';
		const color=document.createElement('span'); color.className='color'; color.style.background=colors[t.id];
		it.appendChild(color); it.appendChild(document.createTextNode(`${t.id} (burst ${t.burst})`));
		legend.appendChild(it);
	});
	el.appendChild(legend);
}

/* Algoritmi scheduler */
function fcfs(tasks){
	const q = tasks.slice().sort((a,b)=>a.arrival - b.arrival || a.id.localeCompare(b.id));
	const schedule=[]; let time=0;
	for(const t of q){
		time = Math.max(time, t.arrival);
		schedule.push({id:t.id, start:time, end:time + t.burst});
		time += t.burst;
	}
	return schedule;
}

function sjfNonPreemptive(tasks){
	const arr = tasks.map(t=>Object.assign({},t)).sort((a,b)=>a.arrival - b.arrival || a.id.localeCompare(b.id));
	const schedule=[]; let time=0; const ready=[]; let i=0;
	while(i<arr.length || ready.length){
		while(i<arr.length && arr[i].arrival<=time) ready.push(arr[i++]);
		if(!ready.length){ time = arr[i].arrival; continue; }
		ready.sort((a,b)=>a.burst - b.burst || a.arrival - b.arrival || a.id.localeCompare(b.id));
		const t = ready.shift();
		schedule.push({id:t.id, start:time, end:time + t.burst});
		time += t.burst;
	}
	return schedule;
}

function priorityNonPreemptive(tasks){
	const arr = tasks.map(t=>Object.assign({},t)).sort((a,b)=>a.arrival - b.arrival || a.id.localeCompare(b.id));
	const schedule=[]; let time=0; const ready=[]; let i=0;
	while(i<arr.length || ready.length){
		while(i<arr.length && arr[i].arrival<=time) ready.push(arr[i++]);
		if(!ready.length){ time = arr[i].arrival; continue; }
		ready.sort((a,b)=>a.priority - b.priority || a.arrival - b.arrival || a.id.localeCompare(b.id));
		const t = ready.shift();
		schedule.push({id:t.id, start:time, end:time + t.burst});
		time += t.burst;
	}
	return schedule;
}

function roundRobin(tasks, quantum){
	const arr = tasks.map(t=>Object.assign({},t)).sort((a,b)=>a.arrival - b.arrival || a.id.localeCompare(b.id));
	const schedule=[]; let time=0; const q=[]; let i=0;
	while(i<arr.length || q.length){
		while(i<arr.length && arr[i].arrival<=time) q.push(Object.assign({},arr[i++]));
		if(!q.length){ time = arr[i].arrival; continue; }
		const cur = q.shift();
		const run = Math.min(quantum, cur.burst);
		schedule.push({id:cur.id, start:time, end: time + run});
		time += run; cur.burst -= run;
		while(i<arr.length && arr[i].arrival<=time) q.push(Object.assign({},arr[i++]));
		if(cur.burst>0) q.push(cur);
	}
	return schedule;
}

/* UI wiring e logica "IA" di suggerimento */
document.getElementById('btnGen').addEventListener('click', ()=>{
	const n = Math.max(1, Number(document.getElementById('genCount').value)||1);
	const tasks = generateTasks(n);
	document.getElementById('jsonInput').value = JSON.stringify(tasks, null, 2);
});

document.getElementById('btnLoad').addEventListener('click', ()=>{
	document.getElementById('jsonInput').value = JSON.stringify([
		{"id":"P1","arrival":0,"burst":5,"priority":2},
		{"id":"P2","arrival":1,"burst":3,"priority":1},
		{"id":"P3","arrival":2,"burst":8,"priority":3}
	], null, 2);
});

const algoSelect = document.getElementById('algo');
algoSelect.addEventListener('change', ()=> {
	document.getElementById('quantumLabel').style.display = algoSelect.value === 'rr' ? 'block' : 'none';
});

document.getElementById('btnRun').addEventListener('click', ()=>{
	const txt = document.getElementById('jsonInput').value;
	const tasks = parseTasks(txt);
	if(!tasks) return;
	const choice = document.getElementById('algo').value;
	const q = Math.max(1, Number(document.getElementById('quantum').value)||2);
	const showSteps = document.getElementById('showSteps').checked;
	const resultsDiv = document.getElementById('results');
	resultsDiv.innerHTML = '';

	// helper per eseguire un algoritmo e mostrare
	function runAndShow(name, sched){
		const metrics = computeMetrics(sched, tasks);
		const container = document.createElement('div');
		container.style.marginTop='10px';
		container.innerHTML = `<div style="font-weight:700">${name}</div>`;
		const tableId = 'tbl_'+Math.random().toString(36).slice(2,8);
		container.innerHTML += `<div id="${tableId}"></div>`;
		resultsDiv.appendChild(container);
		renderTable(metrics.rows, tableId);
		const ganttId = 'gantt_'+Math.random().toString(36).slice(2,8);
		const gDiv = document.createElement('div'); gDiv.id = ganttId; resultsDiv.appendChild(gDiv);
		renderGantt(sched, ganttId, tasks);
		return metrics;
	}

	// choose behavior
	if(choice === 'compare'){
		// run all and pick best by avgWaiting
		const all = [];
		const s1 = fcfs(tasks); all.push({name:'FCFS', sched:s1, metrics:computeMetrics(s1,tasks)});
		const s2 = sjfNonPreemptive(tasks); all.push({name:'SJF', sched:s2, metrics:computeMetrics(s2,tasks)});
		const s3 = priorityNonPreemptive(tasks); all.push({name:'Priority', sched:s3, metrics:computeMetrics(s3,tasks)});
		const s4 = roundRobin(tasks, q); all.push({name:'RoundRobin(q='+q+')', sched:s4, metrics:computeMetrics(s4,tasks)});

		// render summary and detailed
		all.sort((a,b)=>a.metrics.avgWaiting - b.metrics.avgWaiting);
		document.getElementById('summary').innerHTML = `<b>Raccomandazione IA:</b> ${all[0].name} (min avg waiting: ${all[0].metrics.avgWaiting.toFixed(2)})`;
		for(const a of all) runAndShow(a.name, a.sched);
	} else {
		let sched=[];
		if(choice==='fcfs') sched = fcfs(tasks);
		else if(choice==='sjf') sched = sjfNonPreemptive(tasks);
		else if(choice==='priority') sched = priorityNonPreemptive(tasks);
		else if(choice==='rr') sched = roundRobin(tasks, q);
		const m = computeMetrics(sched, tasks);
		document.getElementById('summary').innerHTML = `<b>Algoritmo:</b> ${choice.toUpperCase()} &nbsp;|&nbsp; Tasks: ${m.rows.length} &nbsp;|&nbsp; AvgW: ${m.avgWaiting.toFixed(2)} &nbsp;|&nbsp; Makespan: ${m.makespan}`;
		runAndShow(choice.toUpperCase(), sched);
		if(showSteps) console.log('schedule',sched);
	}
});

document.getElementById('btnClear').addEventListener('click', ()=>{
	document.getElementById('jsonInput').value = '';
	document.getElementById('results').innerHTML = '';
	document.getElementById('summary').innerHTML = 'Pulito';
});
</script>
</body>
</html>
